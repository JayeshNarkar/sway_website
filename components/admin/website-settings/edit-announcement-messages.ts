"use server";

import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { AnnouncementMessage } from "@/lib/prisma";

export default async function editAnnouncementMessages(
  messages: AnnouncementMessage[]
) {
  try {
    // Validate input
    if (!Array.isArray(messages)) {
      return {
        success: false,
        message: "Invalid input: messages must be an array",
      };
    }

    // Check for duplicate sort orders
    const sortOrders = messages.map((m) => m.sortOrder);
    const uniqueSortOrders = new Set(sortOrders);
    if (uniqueSortOrders.size !== messages.length) {
      return {
        success: false,
        message:
          "Duplicate sort orders found. Each message must have a unique sort order.",
      };
    }

    // Check for empty messages
    const emptyMessages = messages.filter(
      (m) => !m.message || m.message.trim().length === 0
    );
    if (emptyMessages.length > 0) {
      return { success: false, message: "Message content cannot be empty" };
    }

    // Check for invalid sort orders (should be positive integers)
    const invalidSortOrders = messages.filter(
      (m) => m.sortOrder < 1 || !Number.isInteger(m.sortOrder)
    );
    if (invalidSortOrders.length > 0) {
      return {
        success: false,
        message: "Sort order must be a positive integer",
      };
    }

    // Get existing messages to identify which ones need to be updated/deleted
    const existingMessages = await prisma.announcementMessage.findMany();
    const existingIds = new Set(existingMessages.map((m) => m.id));

    // Separate messages into updates and new creations
    const messagesToUpdate = messages.filter((m) => existingIds.has(m.id));
    const messagesToCreate = messages.filter((m) => !existingIds.has(m.id));

    // Identify messages to delete (existing messages not in the new array)
    const newIds = new Set(messages.map((m) => m.id));
    const messagesToDelete = existingMessages.filter((m) => !newIds.has(m.id));

    // Use a transaction to ensure all operations succeed or fail together
    await prisma.$transaction(async (tx) => {
      // Delete removed messages
      if (messagesToDelete.length > 0) {
        await tx.announcementMessage.deleteMany({
          where: {
            id: {
              in: messagesToDelete.map((m) => m.id),
            },
          },
        });
      }

      // Update existing messages
      for (const message of messagesToUpdate) {
        await tx.announcementMessage.update({
          where: { id: message.id },
          data: {
            message: message.message,
            sortOrder: message.sortOrder,
            // Note: createdAt is preserved from original
          },
        });
      }

      // Create new messages
      if (messagesToCreate.length > 0) {
        await tx.announcementMessage.createMany({
          data: messagesToCreate.map((m) => ({
            message: m.message,
            sortOrder: m.sortOrder,
            // createdAt will be auto-generated by Prisma
          })),
        });
      }
    });

    revalidatePath("/");
    revalidatePath("/catalogue");
    revalidatePath("/admin/site-settings");

    return {
      success: true,
      message: "Announcement messages updated successfully",
      count: messages.length,
    };
  } catch (error) {
    console.error("Error updating announcement messages:", error);

    if (error instanceof Error) {
      if (error.message.includes("Unique constraint")) {
        return {
          success: false,
          message:
            "Sort order conflict. Please ensure all sort orders are unique.",
        };
      }
      if (error.message.includes("Foreign key constraint")) {
        return {
          success: false,
          message: "Database constraint error. Please check your data.",
        };
      }
    }

    return {
      success: false,
      message: "Failed to update announcement messages. Please try again.",
    };
  }
}
